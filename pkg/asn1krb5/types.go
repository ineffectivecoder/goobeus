package asn1krb5

import (
	"encoding/asn1"
	"time"
)

// Kerberos protocol version
const PVNO = 5

// Message type constants
const (
	MsgTypeASREQ    = 10
	MsgTypeASREP    = 11
	MsgTypeTGSREQ   = 12
	MsgTypeTGSREP   = 13
	MsgTypeAPREQ    = 14
	MsgTypeAPREP    = 15
	MsgTypeKRBSafe  = 20
	MsgTypeKRBPriv  = 21
	MsgTypeKRBCred  = 22
	MsgTypeKRBError = 30
)

// Principal name type constants
//
// EDUCATIONAL: Kerberos Principal Name Types
//
// Principals identify entities in Kerberos. The name-type tells you
// what kind of entity the principal represents:
//
//   - NT-UNKNOWN (0): Name type is unknown
//   - NT-PRINCIPAL (1): Standard user principal (e.g., "jsmith")
//   - NT-SRV-INST (2): Service instance (e.g., "HTTP/webserver")
//   - NT-SRV-HST (3): Service with host as instance (e.g., "host/machine")
//   - NT-SRV-XHST (4): Service with host as remaining components
//   - NT-UID (5): Unique ID
//   - NT-X500-PRINCIPAL (6): X.500 DN
//   - NT-SMTP-NAME (7): SMTP email name
//   - NT-ENTERPRISE (10): Enterprise principal (e.g., "user@domain.com")
const (
	NTUnknown        = 0
	NTPrincipal      = 1
	NTSrvInst        = 2
	NTSrvHst         = 3
	NTSrvXHst        = 4
	NTUID            = 5
	NTX500Principal  = 6
	NTSMTPName       = 7
	NTEnterprise     = 10
	NTWellknown      = 11
	NTSrvInstMSStyle = -128 // Microsoft style, e.g. "host/machine.domain.com"
)

// PrincipalName represents a Kerberos principal name.
//
// EDUCATIONAL: Understanding Principal Names
//
// A principal name consists of:
//   - NameType: What kind of principal this is
//   - NameString: The component parts
//
// Examples:
//
//	User: {Type: 1, String: ["jsmith"]}
//	Service: {Type: 2, String: ["HTTP", "webserver.corp.local"]}
//	SPN: {Type: 2, String: ["MSSQLSvc", "sql01.corp.local:1433"]}
//
// The full principal with realm looks like:
//
//	jsmith@CORP.LOCAL
//	HTTP/webserver.corp.local@CORP.LOCAL
type PrincipalName struct {
	NameType   int32    `asn1:"explicit,tag:0"`
	NameString []string `asn1:"generalstring,explicit,tag:1"`
}

// EncryptedData contains encrypted content.
//
// EDUCATIONAL: Encrypted Data Structure
//
// This structure wraps all encrypted content in Kerberos messages.
// The EType field tells you which encryption algorithm was used:
//
//	23 = RC4-HMAC (key is NTLM hash - pass-the-hash!)
//	17 = AES128-CTS-HMAC-SHA1
//	18 = AES256-CTS-HMAC-SHA1
//
// The Kvno (key version number) helps identify which key was used,
// useful when keys are rotated.
type EncryptedData struct {
	EType  int32  `asn1:"explicit,tag:0"`
	Kvno   int32  `asn1:"optional,explicit,tag:1"`
	Cipher []byte `asn1:"explicit,tag:2"`
}

// EncryptionKey contains a session key.
//
// EDUCATIONAL: Session Keys
//
// Session keys are the symmetric keys used for a specific Kerberos session.
// They're generated by the KDC and shared between principals.
//
// The session key in a TGT is used to encrypt the response to the client.
// The session key in a service ticket is used for the AP exchange.
type EncryptionKey struct {
	KeyType  int32  `asn1:"explicit,tag:0"` // Same as EType values
	KeyValue []byte `asn1:"explicit,tag:1"`
}

// KerberosTime is the Kerberos time format.
//
// EDUCATIONAL: Kerberos Time
//
// Kerberos uses GeneralizedTime format: YYYYMMDDHHMMSSZ
// Always in UTC (Z suffix), no fractional seconds.
//
// Kerberos is sensitive to time skew! By default, clocks must be
// within 5 minutes of each other. This is why time sync matters!
//
// Attack note: If you control time on a client, you can request
// tickets valid far into the future (e.g., Golden Ticket with
// 10-year validity).
type KerberosTime time.Time

// HostAddress represents a network address.
type HostAddress struct {
	AddrType int32  `asn1:"explicit,tag:0"`
	Address  []byte `asn1:"explicit,tag:1"`
}

// HostAddresses is a sequence of HostAddress
type HostAddresses []HostAddress

// AuthorizationData contains authorization information.
//
// EDUCATIONAL: Authorization Data and the PAC
//
// This structure carries authorization information within tickets.
// The most important type is:
//
//	AD-IF-RELEVANT (1): Container for other AD types
//	AD-WIN2K-PAC (128): Windows Privilege Attribute Certificate
//
// The PAC (Privilege Attribute Certificate) is where Windows stores:
//   - User SID
//   - Group SIDs
//   - Logon information
//
// This is what we forge in Golden/Silver ticket attacks!
type AuthorizationData []AuthorizationDataEntry

type AuthorizationDataEntry struct {
	ADType int32  `asn1:"explicit,tag:0"`
	ADData []byte `asn1:"explicit,tag:1"`
}

// PADataType constants
//
// EDUCATIONAL: Pre-Authentication Data Types
//
// Pre-authentication proves you know the password BEFORE the KDC
// issues a ticket. Types include:
//
//	PA-ENC-TIMESTAMP (2): Encrypted timestamp (standard pre-auth)
//	PA-PK-AS-REQ (16): Public key pre-auth (smart cards)
//	PA-PAC-REQUEST (128): Request PAC in ticket
//	PA-FOR-USER (129): S4U2Self impersonation
//	PA-S4U-X509-USER (130): S4U with certificate
const (
	PADataTGSReq       = 1
	PADataEncTimestamp = 2
	PADataPwSalt       = 3
	PADataEncUnixTime  = 5
	PADataSamChallenge = 11
	PADataSamResponse  = 12
	PADataPKASReq      = 16
	PADataPKASRep      = 17
	PADataETYPEInfo    = 11
	PADataETYPEInfo2   = 19
	PADataPACRequest   = 128
	PADataForUser      = 129
	PADataS4UX509User  = 130
	PADataPACOptions   = 167
)

// PAData is pre-authentication data.
type PAData struct {
	PADataType  int32  `asn1:"explicit,tag:1"`
	PADataValue []byte `asn1:"explicit,tag:2"`
}

// PAEncTSEnc is a pre-authentication encrypted timestamp.
//
// EDUCATIONAL: Encrypted Timestamp Pre-Authentication
//
// This is the standard pre-auth mechanism. The client encrypts the
// current timestamp with their password-derived key:
//
//  1. Client gets current time
//  2. Encodes as PA-ENC-TS-ENC
//  3. Encrypts with password-derived key
//  4. Sends in AS-REQ
//
// If an account has "Do not require Kerberos preauthentication" set,
// the KDC will respond with encrypted data WITHOUT validating the
// timestamp first - this enables AS-REP Roasting!
type PAEncTSEnc struct {
	PATimestamp time.Time `asn1:"generalized,explicit,tag:0"`
	PAUsec      int32     `asn1:"optional,explicit,tag:1"`
}

// ETYPEInfo2Entry provides encryption type info for key derivation.
type ETYPEInfo2Entry struct {
	EType     int32  `asn1:"explicit,tag:0"`
	Salt      string `asn1:"optional,generalstring,explicit,tag:1"`
	S2KParams []byte `asn1:"optional,explicit,tag:2"`
}

// Checksum contains an integrity checksum.
type Checksum struct {
	CksumType int32  `asn1:"explicit,tag:0"`
	Checksum  []byte `asn1:"explicit,tag:1"`
}

// Ticket flags
//
// EDUCATIONAL: Ticket Flags
//
// These flags control ticket behavior:
//
//	FORWARDABLE (0x40000000): Can be forwarded to another host
//	FORWARDED (0x20000000): Has been forwarded
//	PROXIABLE (0x10000000): Can be proxied
//	PROXY (0x08000000): Is a proxy
//	RENEWABLE (0x00800000): Can be renewed
//	PRE-AUTHENT (0x00200000): Pre-authenticated
//
// For attacks:
//   - FORWARDABLE is needed for delegation attacks (S4U2Proxy)
//   - RENEWABLE allows extending ticket lifetime
const (
	FlagReserved         = 0x80000000
	FlagForwardable      = 0x40000000
	FlagForwarded        = 0x20000000
	FlagProxiable        = 0x10000000
	FlagProxy            = 0x08000000
	FlagAllowPostdate    = 0x04000000
	FlagPostdated        = 0x02000000
	FlagInvalid          = 0x01000000
	FlagRenewable        = 0x00800000
	FlagInitial          = 0x00400000
	FlagPreAuthent       = 0x00200000
	FlagHWAuthent        = 0x00100000
	FlagTransitedChecked = 0x00080000
	FlagOKAsDelegate     = 0x00040000
	FlagEncPARep         = 0x00010000
	FlagAnonymous        = 0x00008000
)

// TicketFlags is a bitfield of ticket flags.
type TicketFlags asn1.BitString

// KDCOptions for ticket requests
type KDCOptions asn1.BitString

// LastReq entry
type LastReqEntry struct {
	LRType  int32     `asn1:"explicit,tag:0"`
	LRValue time.Time `asn1:"generalized,explicit,tag:1"`
}

// LastReq is a sequence of last request entries
type LastReq []LastReqEntry
